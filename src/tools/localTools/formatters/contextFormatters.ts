/**
 * @fileOverview: Context output formatters for semantic compaction results
 * @module: ContextFormatters
 * @keyFunctions:
 *   - formatContextOutput(): Main formatter dispatcher
 *   - formatContextAsXML(): XML format for structured data exchange
 *   - formatContextAsStructured(): Markdown format for human readability
 *   - formatContextAsCompact(): Minimal format for space-constrained environments
 * @context: Provides multiple output formats for semantic compaction results
 */

/**
 * Main formatter dispatcher for context output
 */
export function formatContextOutput(result: any, format: string, metadata: any): string {
  switch (format) {
    case 'xml':
      return formatContextAsXML(result, metadata);
    case 'structured':
      return formatContextAsStructured(result, metadata);
    case 'compact':
      return formatContextAsCompact(result, metadata);
    default:
      return formatContextAsStructured(result, metadata);
  }
}

/**
 * Format context results as XML for structured data exchange
 */
export function formatContextAsXML(result: any, metadata: any): string {
  const { originalTokens, query, taskType, projectPath } = metadata;

  return `<?xml version="1.0" encoding="UTF-8"?>
<context>
  <metadata>
    <project_path>${escapeXml(projectPath)}</project_path>
    <query>${query ? escapeXml(query) : ''}</query>
    <task_type>${taskType}</task_type>
    <compression>
      <original_tokens>${originalTokens}</original_tokens>
      <compacted_tokens>${result.totalTokens}</compacted_tokens>
      <ratio>${result.compressionRatio}</ratio>
    </compression>
    <processing>
      <files_processed>${result.processingStats?.filesProcessed || 0}</files_processed>
      <symbols_found>${result.processingStats?.totalSymbols || 0}</symbols_found>
      <symbols_after_deduplication>${result.processingStats?.symbolsAfterDeduplication || 0}</symbols_after_deduplication>
      <processing_time_ms>${result.processingStats?.processingTimeMs || 0}</processing_time_ms>
    </processing>
  </metadata>
  <content>
    <![CDATA[${result.compactedContent}]]>
  </content>
</context>`;
}

/**
 * Format context results as structured markdown for human readability
 */
export function formatContextAsStructured(result: any, metadata: any): string {
  const { originalTokens, query, taskType, projectPath } = metadata;

  return `# ðŸ”§ Local Context Analysis

## Query Information
- **Project:** ${projectPath}
- **Query:** ${query || 'General context'}
- **Task Type:** ${taskType}

## Compression Results
- **Original Tokens:** ${originalTokens}
- **Compacted Tokens:** ${result.totalTokens}
- **Compression Ratio:** ${Math.round(result.compressionRatio * 100)}%

## Processing Statistics
- **Files Processed:** ${result.processingStats?.filesProcessed || 0}
- **Symbols Found:** ${result.processingStats?.totalSymbols || 0}
- **Symbols After Deduplication:** ${result.processingStats?.symbolsAfterDeduplication || 0}
- **Processing Time:** ${result.processingStats?.processingTimeMs || 0}ms

## Compacted Context

${result.compactedContent}

---
*Generated by Local Semantic Compactor with ${Math.round(result.compressionRatio * 100)}% token reduction*`;
}

/**
 * Format context results in compact format for space-constrained environments
 */
export function formatContextAsCompact(result: any, metadata: any): string {
  const { originalTokens, query, taskType } = metadata;
  return `CONTEXT | QUERY: ${query || 'General'} | TASK: ${taskType} | TOKENS: ${originalTokens}â†’${result.totalTokens} (${Math.round(result.compressionRatio * 100)}%)
FILES: ${result.processingStats?.filesProcessed || 0} | SYMBOLS: ${result.processingStats?.totalSymbols || 0}â†’${result.processingStats?.symbolsAfterDeduplication || 0}

${result.compactedContent}`;
}

/**
 * Escape XML special characters
 */
export function escapeXml(text: string): string {
  if (typeof text !== 'string') return String(text);
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}
