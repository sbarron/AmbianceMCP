/**
 * @fileOverview: AI Context Analysis Output Formatters
 * @module: AISemanticFormatters
 * @keyFunctions:
 *   - formatAISemanticOutput: Main formatter dispatcher
 *   - formatAsXML: Machine-readable XML format
 *   - formatAsMarkdown: Documentation-ready markdown format
 *   - formatAsStructured: Detailed structured text format
 * @context: Provides multiple output formats for AI-powered context analysis results
 */

/**
 * Format AI context analysis output according to requested format
 */
export function formatAISemanticOutput(data: any, format: string): string {
  switch (format) {
    case 'xml':
      return formatAsXML(data);
    case 'markdown':
      return formatAsMarkdown(data);
    case 'structured':
      return formatAsStructured(data);
    case 'json':
    default:
      return JSON.stringify(data, null, 2);
  }
}

/**
 * Format as XML for machine processing
 */
export function formatAsXML(data: any): string {
  const escapeXml = (text: string) =>
    text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');

  return `<?xml version="1.0" encoding="UTF-8"?>
<semantic_analysis>
  <metadata>
    <project_path>${escapeXml(data.projectPath)}</project_path>
    <query>${escapeXml(data.query)}</query>
    <task_type>${data.taskType}</task_type>
    <complexity>${data.complexity}</complexity>
    <processing_time>${data.metadata.processingTime}ms</processing_time>
    <token_usage>
      <estimated>${data.metadata.tokenUsage.estimated}</estimated>
      <ai_response>${data.metadata.tokenUsage.aiResponse}</ai_response>
      <max_allocated>${data.metadata.tokenUsage.maxAllocated}</max_allocated>
    </token_usage>
  </metadata>
  <local_compaction>
    <files_analyzed>${data.localCompaction.filesAnalyzed}</files_analyzed>
    <total_symbols>${data.localCompaction.totalSymbols}</total_symbols>
    <compression_ratio>${data.localCompaction.compressionRatio}</compression_ratio>
    <patterns>
      ${
        data.localCompaction.patterns && Array.isArray(data.localCompaction.patterns)
          ? data.localCompaction.patterns
              .map((p: string) => `<pattern>${escapeXml(p)}</pattern>`)
              .join('\n      ')
          : '<pattern>No patterns detected</pattern>'
      }
    </patterns>
  </local_compaction>
  <ai_analysis>
    <![CDATA[${data.analysis}]]>
  </ai_analysis>
  <context>
    ${data.context
      .map(
        (file: any) => `
    <file>
      <path>${escapeXml(file.path)}</path>
      <language>${file.language}</language>
      <purpose>${escapeXml(file.purpose)}</purpose>
      <symbol_count>${file.symbols.length}</symbol_count>
      <exports>${file.exports.map((e: string) => `<export>${escapeXml(e)}</export>`).join('')}</exports>
    </file>`
      )
      .join('')}
  </context>
</semantic_analysis>`;
}

/**
 * Format as Markdown for documentation
 */
export function formatAsMarkdown(data: any): string {
  const formatDuration = (ms: number) => (ms > 1000 ? `${(ms / 1000).toFixed(1)}s` : `${ms}ms`);

  return `# 🤖 AI Context Analysis Report

## 📋 Analysis Overview

- **Project:** \`${data.projectPath}\`
- **Query:** ${data.query}
- **Task Type:** ${data.taskType}
- **Complexity:** ${data.complexity}
- **Processing Time:** ${formatDuration(data.metadata.processingTime)}

## 📊 Compaction Results

- **Files Analyzed:** ${data.localCompaction.filesAnalyzed}
- **Total Symbols:** ${data.localCompaction.totalSymbols}
- **Compression Ratio:** ${Math.round(data.localCompaction.compressionRatio * 100)}%
- **Patterns Detected:** ${data.localCompaction.patterns.join(', ')}

## 🔍 AI Analysis

${data.analysis}

## 📁 Analyzed Files

${data.context
  .map(
    (file: any) => `
### \`${file.path}\`

- **Language:** ${file.language}
- **Purpose:** ${file.purpose}
- **Symbols:** ${file.symbols.length}
- **Exports:** ${file.exports.join(', ') || 'None'}
`
  )
  .join('')}

## 📈 Performance Metrics

- **Token Usage:**
  - Estimated Context: ${data.metadata.tokenUsage.estimated}
  - AI Response: ${data.metadata.tokenUsage.aiResponse}
  - Max Allocated: ${data.metadata.tokenUsage.maxAllocated}
- **Provider:** ${data.metadata.provider} (${data.metadata.model})

---
*Generated by AI-Powered Context Analysis*`;
}

/**
 * Format as structured text for detailed analysis
 */
export function formatAsStructured(data: any): string {
  const formatDuration = (ms: number) => (ms > 1000 ? `${(ms / 1000).toFixed(1)}s` : `${ms}ms`);

  return `🤖 AI-POWERED CONTEXT ANALYSIS REPORT
=====================================

PROJECT INFORMATION
------------------
Path: ${data.projectPath}
Query: ${data.query}
Task Type: ${data.taskType}
Complexity: ${data.complexity}
Processing Time: ${formatDuration(data.metadata.processingTime)}

COMPACTION STATISTICS
--------------------
Files Analyzed: ${data.localCompaction.filesAnalyzed}
Total Symbols: ${data.localCompaction.totalSymbols}
Compression Ratio: ${Math.round(data.localCompaction.compressionRatio * 100)}%
Detected Patterns:
${
  data.localCompaction.patterns &&
  Array.isArray(data.localCompaction.patterns) &&
  data.localCompaction.patterns.length > 0
    ? data.localCompaction.patterns.map((p: string) => `  • ${p}`).join('\n')
    : '  • No patterns detected'
}

AI ANALYSIS
-----------
${data.analysis}

ANALYZED FILES
--------------
${data.context
  .map(
    (file: any, index: number) => `
${index + 1}. ${file.path}
   Language: ${file.language}
   Purpose: ${file.purpose}
   Symbols: ${file.symbols && Array.isArray(file.symbols) ? file.symbols.length : 0}
   Exports: ${file.exports && Array.isArray(file.exports) ? file.exports.join(', ') || 'None' : 'None'}
   Key Symbols:
${
  file.symbols && Array.isArray(file.symbols) && file.symbols.length > 0
    ? file.symbols
        .slice(0, 3)
        .map((s: any) => `     - ${s.name || s} (${s.type || 'unknown'})`)
        .join('\n')
    : '     - No symbols available'
}
`
  )
  .join('')}

PERFORMANCE METRICS
------------------
Token Usage:
  Estimated Context: ${data.metadata.tokenUsage.estimated}
  AI Response: ${data.metadata.tokenUsage.aiResponse}
  Max Allocated: ${data.metadata.tokenUsage.maxAllocated}
  
Provider: ${data.metadata.provider} (${data.metadata.model})

=====================================
Generated by AI-Powered Context Analysis`;
}
